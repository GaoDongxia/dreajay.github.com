<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

    
    
    
  <url>
    <loc>http://dreajay.github.io/2014/11/30/effective%20java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</loc>
    <lastmod>2014-11-30T15:02:53.000Z</lastmod>
    <data>
        <display>
        <title>effective java-读书笔记-第三章 对于所有对象都通用的方法</title>
        <pubTime>2014-11-30T14:57:04.000Z</pubTime>
        
        <tag>effective java </tag>
         
        <tag>读书笔记 </tag>
         
         <content><![CDATA[<h1 id="第三章_对于所有对象都通用的方法">第三章 对于所有对象都通用的方法</h1>
<p>所有非final方法（equals、hashCode、toString、clone、finalize）都有明确的通用约定，因为它们被设计成是要被覆盖的，如果不遵守，基于散列的集合（HashMap、HashSet、HashTable）可能无法结合该类一起运作。</p>
<h2 id="第8条_覆盖equals时请遵守通用约定">第8条 覆盖equals时请遵守通用约定</h2>
<p><strong>覆盖equals规范：</strong></p>
<ol>
<li>自反性（reflexive）。对于任何非null的引用值x，x.equals(x)必须返回true。</li>
<li>对称性（symmetric）。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li>
<li>传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)必须返回true。</li>
<li>一致性（consistent）。对于任何非null的引用值x和y，只有equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回true或者false。</li>
</ol>
<p><strong>实现equals方法：</strong></p>
<ol>
<li>使用==操作符检查“参数是否为这个对象的引用”。如果是，返回true。</li>
<li>使用instanceof操作符检查”参数是否为正确的类型”。如果不是返回false。</li>
<li>把参数转换成正确的类型。转换之前用instanceof判断，确保正确。</li>
<li>对于该类中的每个”关键“字段，检查参数中的字段是否与该对象中对应的字段相匹配。如果这些测试检查成功，返回true，否则返回false。</li>
<li>当编写完equals方法，编写单元测试校验它是否是对称的、传递的、一致的。</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>覆盖equals方法时总要覆盖hashCode方法。</li>
<li>不要企图让equals方法过于智能。比如File不应该和文件链接当作相等来看待。</li>
<li>不要将equals方法声明中的Object对象替换为其他类型。</li>
</ol>
<h2 id="第9条_覆盖equals时总要覆盖hashCode">第9条 覆盖equals时总要覆盖hashCode</h2>
<p>hashcode方法返回该对象的哈希码值。通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
<p><strong>hashCode常规协定</strong></p>
<ol>
<li>在应用程序执行期间，只要对象的equals方法的比较操作中所用的信息没有被修改，那么对这同一对象多次调用，hashCode方法都必须一致地返回同样的整数。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 </li>
<li>如果两个对象根据equals(Object)方法比较是相等的，那么调用两个对象中的任意一个对象上hashCode 方法都必须产生相同的整数结果。 </li>
<li>如果两个对象根据equals(Object)方法比较是不相等的，那么调用两个对象中的任意一个对象上hashCode 方法，则不一定产生不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 </li>
</ol>
<p><em>对于equals()相等的两个对象，其hashCode()返回的值一定相等</em></p>
<p><strong>重写hashCode方法</strong></p>
<ol>
<li>保证equals相等的对象hash码要一定相等</li>
<li>对于equals不同的对象要尽量做到hash码不同<br>具体步骤就是：<br>[1]把某个非零常数值（一般取素数），例如17，保存在int变量result中；<br>[2]对于对象中每一个关键域f（指equals方法中考虑的每一个域）：<br>[2.1]boolean型，计算(f ? 0 : 1);<br>[2.2]byte、char、short、int型，计算(int)f;<br>[2.3]long型，计算(int) (f ^ (f&gt;&gt;&gt;32));<br>[2.4]float型，计算Float.floatToIntBits(afloat);<br>[2.5]double型，计算Double.doubleToLongBits(adouble)得到一个long，再执行[2.3];<br>[2.6]对象引用，递归调用它的hashCode方法;<br>[2.7]数组域，对其中每个元素调用它的hashCode方法。<br>[3]将上面计算得到的散列码保存到int变量c，然后执行 result=37<em>result+c;<br>[4]返回result。<br>其实其思路就是：先取一个基数，然后对于equals()中考虑的每一个域，先转换成整数，再执行result=37</em>result+c;例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>(){</div><div class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</div><div class="line">    result = <span class="number">31</span>*result+age;</div><div class="line">    result=<span class="number">31</span>*result+name.hashCode();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="第10条_始终要覆盖toString">第10条 始终要覆盖toString</h2>
<p>toString通用约定指出被返回的字符串应该是简洁的、但信息丰富，并且易于阅读的表达形式。提供好的toString方法可以使类用起来更加舒适，当对象被传递给println、pringtf、字符串联合操作+、日志打印，toString会被自动调用。</p>
<p><em>建议所有的子类都覆盖toString方法。</em></p>
<h2 id="第11条_谨慎地覆盖clone">第11条 谨慎地覆盖clone</h2>
<p>Cloneable接口表明这样的对象允许克隆，它没有包含任何方法，它改变了超类中受保护的方法clone的行为，如果一个类实现了Cloneable接口，Object的clone方法就返回该对象的逐层拷贝，否则就会抛出CloneNotSupportException异常。</p>
<p>覆盖clone方法要非常小心，如果类里面含有复杂数据类型，要进行深度复制，如果类里面有final属性，则无法进行clone，因为final属性在clone时无法再进行赋值。</p>
<p><em>建议对象不使用clone方法，而使用静态拷贝工厂或拷贝构造器替代clone方法</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Obj</span>(Obj obj);</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Obj <span class="title">newInstance</span>(Obj obj);</div></pre></td></tr></table></figure>

<h2 id="第12条_考虑实现Comparable接口">第12条 考虑实现Comparable接口</h2>
<p>Comparable接口表明它的实例具有内在排序关系。</p>
<p><strong>Comparable声明：</strong></p>
<ol>
<li>如果第一个对象小于第二个对象，则第二个对象一定大于第一个对象；如果第一个对象等于第二个对象，则第二个对象一定等于第一个对象；如果第一个对象大于第二个对象，则第二个对象一定小于第一个对象。</li>
<li>如果第一个对象大于第二个对象，并且第二个对象又大于第三个对象，那么第一个对象一定大于第三个对象。</li>
<li>在比较时被认为相等的所有对象，它们跟别的对象做比较时一定会产生同样的结果。</li>
</ol>
<p>Comparable的声明和equals的声明类似，也遵守自反性、对称性和传递性。</p>
<p><em>强烈建议( (x.compareTo(y)==0)==(x.eauals(y) )，但这并非绝对必要。</em></p>
<p><strong>Comparable实现</strong></p>
<p>compareTo方法中的域的比较时顺序的比较，而不是等同性的比较。笔记对象引用域可以使通过递归地调用compareTo方法来实现。如果一个域没有实现Comparable接口，或者你需要一个非标准的排序关系，就可以使用一个显示的Comparator接口来代替。</p>
<figure class="highlight 例子"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span>(PhoneNumber pn) {</div><div class="line">        <span class="keyword">int</span> areaCodeDiff = areaCode - pn.areaCode;</div><div class="line">        <span class="keyword">if</span> (areaCodeDiff != <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> areaCodeDiff;</div><div class="line">        <span class="keyword">int</span> prefixDiff = prefix - pn.prefix;</div><div class="line">        <span class="keyword">if</span> (prefixDiff != <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> prefixDiff;</div><div class="line">        <span class="comment">// 下面可能会发生超出int最大值异常</span></div><div class="line">        <span class="keyword">return</span> lineNumber - pn.lineNumber;</div><div class="line">    }</div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="java" url="http://dreajay.github.io/categories/java/"/>
          
             
              <breadCrumb title="读书笔记" url="http://dreajay.github.io/categories/java/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://dreajay.github.io/2014/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</loc>
    <lastmod>2014-11-28T13:04:57.000Z</lastmod>
    <data>
        <display>
        <title>设计模式之单例模式</title>
        <pubTime>2014-11-18T17:49:49.000Z</pubTime>
        
        <tag>设计模式 </tag>
         
        <tag>单例模式 </tag>
         
        <tag>Singleton模式 </tag>
         
         <content><![CDATA[<h2 id="定义">定义</h2>
<p>Singleton是指在应用程序中只被实例化一次的类。</p>
<a id="more"></a>

<h2 id="创建单例模式的方法">创建单例模式的方法</h2>
<h3 id="第一种">第一种</h3>
<p>恶汉式，程序加载自己时就会创建静态Singleton实例。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过静态final变量获取Singleton</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过静态方法获取实例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第二种">第二种</h3>
<p>懒汉式，当需要使用的时候再进行创建，使用synchronized锁保证只能生成一个实例，否则多线程下可能会产生多个实例，但synchronized会导致性能下降。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">            sinleton = <span class="keyword">new</span> Singleton();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sinleton;</div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第三种">第三种</h3>
<p>懒汉式，下面这种方法是上面方法的改进，但多线程下可能造成创建多个实例问题，假如第一次在创建对象的时候，另外一个线程已经进入if(singleton == null) 中等待synchronized，最后执行完就会产生两个Singleton，导致单例失效。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class) {</div><div class="line">                sinleton = <span class="keyword">new</span> Singleton();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sinleton;</div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第四种">第四种</h3>
<p>这个方法避免了第三种创建多个实例对象的问题，并且避免了多个线程排队等候的现象。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class){</div><div class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">                    sinleton = <span class="keyword">new</span> Singleton();</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sinleton;</div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第五种">第五种</h3>
<p>改良的懒汉模式，通过私有静态final内部类间接构造Singleton。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {}  </div><div class="line">    <span class="comment">//私有静态</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>{  </div><div class="line">        <span class="comment">//static final Singleton</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {  </div><div class="line">        <span class="keyword">return</span> Holder.instance;  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第六种">第六种</h3>
<p>枚举实现单例模式，在《effective java》一书中有介绍，这是实现单例的最佳方式。之前第一种方法第一个例子通过静态final变量获取Singleton，通过反射调用私有构造器可以创建另一个实例，会导致破坏Singleton，防御方法为是在构造器中进行判断第二次创建时抛出异常；另外一方面为了给Singleton序列化(Serializable)，仅仅在声明中加上“implements Serializable ”，是不够的，为了保证Singleton，必须声明所有实例域都是瞬时的（transient），并提供一个readResolve方法，否则每次反序列化时都会创建一个新的实例，使用枚举方法简洁并无偿的提供了序列化机制，绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton {</div><div class="line">    INSTANCE {</div><div class="line">        <span class="comment">// init . . .</span></div><div class="line">    };</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span>() {</div><div class="line">        <span class="comment">// do . . .</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>枚举创建单例这么多好处，以后应该多用枚举方式来实现单例模式；当Singleton不需要序列化，或一般不会被反射时，我一般使用第一种恶汉式来创建，简单，也不需要考虑多线程，虽然一开始就需要消耗内存去创建，但现在的机器是不用太担心的，恶汉式会让单例变得更加复杂。<br><strong><em>注意：</em></strong><br>在分布式式中，程序可能会跨服务器、跨JVM，包含多个类装载器，Singleton可能会被不同的类装载器装载，这样就会导致Singleton失效。</p>
]]></content>
         
         
           
             
              <breadCrumb title="设计模式" url="http://dreajay.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
          
        </display>
    </data>
    </url>

    
    
    
  <url>
    <loc>http://dreajay.github.io/2014/11/24/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</loc>
    <lastmod>2014-11-25T11:22:10.000Z</lastmod>
    <data>
        <display>
        <title>hexo+github搭建博客系统</title>
        <pubTime>2014-11-24T13:02:40.000Z</pubTime>
        
        <tag>博客 </tag>
         
        <tag>hexo </tag>
         
        <tag>github </tag>
         
        <tag>markdown </tag>
         
         <content><![CDATA[<p>个人博客大概包含了以下几个模块：首页、文章存档、文章分类、关于、友情链接，有些博客资源丰富，功能强大，还会加上一些诸如站内搜索、评论、分享、微博秀、广告等一些功能，很多框架都可以快速搭建起一个包含以上功能的博客，关于有哪些框架可以搭建博客，可以移步知乎讨论：<a href="http://www.zhihu.com/question/21981094" target="_blank" rel="external">应用github pages创建自己的个人博客</a>。<br><a id="more"></a><br>本博客是用hexo+github搭建的，选择<a href="http://hexo.io/" target="_blank" rel="external">hexo</a>是因为它比较简单，选择<a href="https://github.com" target="_blank" rel="external">github</a>因为它免费，哈哈，免费的东西总是能让人趋之若鹜。本博客的搭建也是参考很多他人资料，会在后面列出，我这里总结一下自己搭建博客各个模块用到的资源。</p>
<h1 id="创建github博客">创建github博客</h1>
<p>IT人员应该人手必备一个<a href="https://github.com" target="_blank" rel="external">github</a>账号，否则无法跟上这个逼格的年代，先注册一个github账号，然后创建自己的博客GitHub Pages，仓库名字固定结尾github.io，加上你的前缀，比如xxx.github.io。这里不会具体展开，相信你能做到：<a href="http://jingyan.baidu.com/article/ed2a5d1f3732cb09f7be1745.html" target="_blank" rel="external">http://jingyan.baidu.com/article/ed2a5d1f3732cb09f7be1745.html</a>。</p>
<h1 id="hexo">hexo</h1>
<h2 id="安装">安装</h2>
<p>因为<a href="http://hexo.io/" target="_blank" rel="external">hexo</a>是居于note.js的，所以要安装hexo，必须先安装note.js环境，这里并不一定需要很深入的了解notejs，如果你只想简单的使用hexo的话，安装很简单，直接到官网下载安装：<a href="http://www.nodejs.org" target="_blank" rel="external">http://www.nodejs.org</a>，安装完了notejs，打开命令行[cmd、git bash]执行命令即可安装hexo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo</div></pre></td></tr></table></figure>

<h2 id="快速开始">快速开始</h2>
<p><a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>的官网有很多文档资料，花一点时间看看文档，对你很有帮助，虽然是英文，但是不难，下面介绍几个常用的命令来搭建hexo博客。</p>
<h3 id="创建博客">创建博客</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo init c:/blog</div><div class="line">$ npm install</div></pre></td></tr></table></figure>

<h3 id="新建一篇文章">新建一篇文章</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"test"</span></div></pre></td></tr></table></figure>

<p>在sourece/_posts目录下会生成一个test.md文件，md为markdown文件格式，你可以用记事本来编辑，不过我更加推荐sublime text这款编辑器。markdown非常简单，更多请参考：<a href="https://github.com/riku/Markdown-Syntax-CN" target="_blank" rel="external">Markdown 语法 (简体中文版)</a>，在线编辑工具：<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">作业部落Cmd</a>, <a href="http://maxiang.info/" target="_blank" rel="external">马克飞象</a>。</p>
<h3 id="运行服务">运行服务</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure>

<p>访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>，即可看到刚才的文章。</p>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态文件">生成静态文件</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure>

<h3 id="发布到github">发布到github</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div></pre></td></tr></table></figure>

<p>需要在_config.yml配置你的github博客地址。</p>
<h2 id="hexo主题">hexo主题</h2>
<p>hexo有很多漂亮的主题：<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/hexojs/hexo/wiki/Themes</a>，你可以拿来修改成自己的，再次提醒参考<a href="http://hexo.io/docs/" target="_blank" rel="external">hexo</a>官方文档对你很有帮助。</p>
<h1 id="功能扩展">功能扩展</h1>
<p>给博客添加一些额外的功能，比如添加RSS订阅、分享、评论、404页面等待，这里不会具体展开怎么去做，具体还是需要自己去实践，可参看前人博客。</p>
<h2 id="网站图标">网站图标</h2>
<p><a href="http://www.bitbug.net/" target="_blank" rel="external">http://www.bitbug.net/</a><br><a href="http://creatr.cc/creatr/" target="_blank" rel="external">http://creatr.cc/creatr/</a></p>
<h2 id="分享">分享</h2>
<p>加网：<a href="http://www.jiathis.com/" target="_blank" rel="external">http://www.jiathis.com/</a><br>百度：<a href="http://share.baidu.com/code" target="_blank" rel="external">http://share.baidu.com/code</a><br>bShare：<a href="http://www.bshare.cn/" target="_blank" rel="external">http://www.bshare.cn/</a></p>
<h2 id="评论">评论</h2>
<p>多说：<a href="http://duoshuocom/" target="_blank" rel="external">http://duoshuo.com/</a> 国内用得多，方便快速<br>disqus：<a href="https://www.disqus.com/" target="_blank" rel="external">https://www.disqus.com/</a> 功能强大</p>
<h2 id="新浪微博秀">新浪微博秀</h2>
<p>微博秀：<a href="http://open.weibo.com/widget/like.php" target="_blank" rel="external">http://open.weibo.com/widget/like.php</a></p>
<h2 id="fork_me_on_github">fork me on github</h2>
<p>给博客加入github的fork链接：<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="external">https://github.com/blog/273-github-ribbons</a></p>
<h2 id="回到顶部">回到顶部</h2>
<p>参考文章：<a href="http://wuchong.me/blog/2014/01/08/hexo-scrollup/" target="_blank" rel="external">http://wuchong.me/blog/2014/01/08/hexo-scrollup/</a></p>
<h2 id="百度统计">百度统计</h2>
<p><a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">http://tongji.baidu.com/web/welcome/login</a></p>
<h2 id="站内搜索">站内搜索</h2>
<p>百度站长平台包含站内搜索并且还有其他很多功能：<a href="http://zhanzhang.baidu.com/" target="_blank" rel="external">http://zhanzhang.baidu.com/</a></p>
<h2 id="RSS订阅和sitemap">RSS订阅和sitemap</h2>
<p>RSS和sitemap有现成的插件可以很快集成到hexo，安装插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div><div class="line">$ npm install hexo-generator-sitemap</div></pre></td></tr></table></figure>

<p>修改_config.yml，增加以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Plugins:</div><div class="line">- hexo-generator-feed</div><div class="line">- hexo-generator-sitemap</div><div class="line"></div><div class="line"><span class="comment">#Feed Atom</span></div><div class="line">feed:</div><div class="line">  <span class="built_in">type</span>: atom</div><div class="line">  path: atom.xml</div><div class="line">  limit: <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment">#sitemap</span></div><div class="line">sitemap:</div><div class="line">  path: sitemap.xml</div></pre></td></tr></table></figure>

<p>执行命令 hexo d 能生成下面2个文件即表示成功：<br>xxx/public/atom.xml<br>xxx/public/sitemap.xml</p>
<h2 id="404页面">404页面</h2>
<p>当找不到你的网页时，提供一个友好的404会显得你更加专业。<br>腾讯404公益页面：<a href="http://www.qq.com/404/" target="_blank" rel="external">http://www.qq.com/404/</a></p>
<h2 id="图床">图床</h2>
<p>图床是用来存储你的图片的，你上传一张本地图片，图床会给你生成一个链接，你引用链接即可找到你的图片，有很多免费的图床可用：新浪、七牛。</p>
<h1 id="参考资料">参考资料</h1>
<hr>
<p>[1] <a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a> by cnfeat<br>[2] <a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">hexo 系列教程</a> by zippera<br>[3] <a href="http://zipperary.com/2013/05/26/ssh-errors-with-github/" target="_blank" rel="external">Git push时重复输入用户名密码的问题</a> by zippera</p>
]]></content>
         
         
           
             
              <breadCrumb title="博客" url="http://dreajay.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
          
             
              <breadCrumb title="hexo" url="http://dreajay.github.io/categories/%E5%8D%9A%E5%AE%A2/hexo/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://dreajay.github.io/2014/11/25/%E8%BF%9B%E5%8C%96%EF%BC%9A%E5%B1%8C%E4%B8%9D%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E9%80%86%E8%A2%AD%E4%B9%8B%E8%B7%AF/</loc>
    <lastmod>2014-11-25T05:33:33.000Z</lastmod>
    <data>
        <display>
        <title>进化：屌丝的互联网逆袭之路</title>
        <pubTime>2014-11-25T05:10:13.000Z</pubTime>
        
        <tag>职业规划 </tag>
         
        <tag>互联网 </tag>
         
        <tag>迷茫 </tag>
         
         <content><![CDATA[<p>这是我在CSDN参加《<a href="http://blog.csdn.net/blogdevteam/article/details/40047403" target="_blank" rel="external">有奖试读&amp;征文——我们在互联网上奋斗的故事</a>》活动写的一篇读后感，并且获奖。</p>
<p>文章内容包括：</p>
<pre><code><span class="bullet">1. </span>书籍介绍
<span class="bullet">2. </span>屌丝的现状
<span class="bullet">3. </span>激情燃烧的岁月-互联网进化
<span class="bullet">4. </span>屌丝逆袭之路进化为互联网高富帅
<span class="bullet">5. </span>后记
<span class="bullet">6. </span>资料推荐
</code></pre><p>原文：<a href="http://blog.csdn.net/dreajay/article/details/40812623" target="_blank" rel="external">进化：屌丝的互联网逆袭之路</a>。</p>
]]></content>
         
         
           
             
              <breadCrumb title="职业规划" url="http://dreajay.github.io/categories/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
          
        </display>
    </data>
    </url>

    
    
    
  <url>
    <loc>http://dreajay.github.io/2014/11/21/mybatis%E5%AE%9E%E6%88%98%E4%B9%8BSqlSessionFactory/</loc>
    <lastmod>2014-11-21T07:46:05.000Z</lastmod>
    <data>
        <display>
        <title>mybatis实战之构建SqlSessionFactory</title>
        <pubTime>2014-11-21T03:40:57.000Z</pubTime>
        
        <tag>java </tag>
         
        <tag>mybatis </tag>
         
        <tag>SqlSessionFactory </tag>
         
         <content><![CDATA[<p>SqlSessionFactory是mybatis的重要角色，是mybatis的整个程序的入口.<br><a id="more"></a></p>
<ol>
<li><p>SqlSessionFactory生命周期<br>SqlSessionFactory生命周期为贯穿整个应用程序,一般保持生命周期都使用同一个实例，所以SqlSessionFactory应该保持全局静态变量或使用单利模式来使用它。如果有多个数据源的时候，需要创建不同的SqlSessionFactory。</p>
</li>
<li><p>构建SqlSessionFactory<br>在mybatis中构建SqlSessionFactory有两种方式，一种是根据xml配置文件方式，另一种是也手动编写Java代码方式，手动构建比较繁琐，也不好维护，推荐使用xml配置方式，下面是详细代码。</p>
</li>
</ol>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * SqlSessionFactory生命周期为贯穿整个应用程序,一般保持生命周期都使用同一个实例，所以SqlSessionFactory应该保持全局静态变量或使用单利模式来使用它</div><div class="line"> * </div><div class="line"> *<span class="javadoctag"> @author</span> dreajay</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryManager</span> </span>{</div><div class="line">    <span class="comment">// SqlSessionFactory一个实例对应一个数据库配置</span></div><div class="line">    <span class="keyword">public</span> SqlSessionFactory sqlSessionFactory;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactoryManager INSTANCE = <span class="keyword">new</span> SqlSessionFactoryManager();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="title">SqlSessionFactoryManager</span>() {</div><div class="line">        sqlSessionFactory = buildSqlSessionFactoryFromXML(<span class="string">"SqlMapConfig.xml"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span>() {</div><div class="line">        <span class="keyword">return</span> INSTANCE.sqlSessionFactory;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * 根据配置文件创建SqlSessionFactory</div><div class="line">     * </div><div class="line">     *<span class="javadoctag"> @param</span> SqlMapConfigFile</div><div class="line">     *            SqlMapConfig配置文件，文件应该放在当前的classpath中</div><div class="line">     *<span class="javadoctag"> @return</span> SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> SqlSessionFactory <span class="title">buildSqlSessionFactoryFromXML</span>(String SqlMapConfigFile) {</div><div class="line">        Reader reader = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            reader = Resources.getResourceAsReader(SqlMapConfigFile);</div><div class="line">            <span class="comment">// SqlSessionFactoryBuilder创建完SqlSessionFactory就不需要了，生命周期在方法内，不需要保存本地变量</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">            Log4jUtil.error(SqlSessionFactoryManager.class, <span class="string">"创建SqlSessionFactory出错"</span>, e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    reader.close();</div><div class="line">                    reader = <span class="keyword">null</span>;</div><div class="line">                } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * 手动创建SqlSessionFactory</div><div class="line">     * </div><div class="line">     *<span class="javadoctag"> @return</span> SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> SqlSessionFactory <span class="title">buildSqlSessionFactoryFromJava</span>() {</div><div class="line">        DataSource dataSource = <span class="keyword">null</span>;<span class="comment">// 数据库连接</span></div><div class="line">        <span class="comment">// dataSource = BlogDataSourceFactory.getBlogDataSource();</span></div><div class="line">        TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</div><div class="line">        Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</div><div class="line">        Configuration configuration = <span class="keyword">new</span> Configuration(environment);</div><div class="line">        configuration.addMapper(UserMapper.class);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
         
         
           
             
              <breadCrumb title="java" url="http://dreajay.github.io/categories/java/"/>
          
             
              <breadCrumb title="mybatis" url="http://dreajay.github.io/categories/java/mybatis/"/>
          
        </display>
    </data>
    </url>

</urlset>
