<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[dreajay's blog]]></title>
  <subtitle><![CDATA[戴竣杰的博客专栏，梦想还是要有的，万一实现了呢！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dreajay.github.io/"/>
  <updated>2014-12-07T08:17:14.324Z</updated>
  <id>http://dreajay.github.io/</id>
  
  <author>
    <name><![CDATA[dreajay]]></name>
    <email><![CDATA[dreajay@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[effective java-读书笔记-第四章 类和接口]]></title>
    <link href="http://dreajay.github.io/2014/12/01/effective%20java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://dreajay.github.io/2014/12/01/effective java-读书笔记-第四章 类和接口/</id>
    <published>2014-12-01T13:01:21.000Z</published>
    <updated>2014-12-06T13:55:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第四章_类和接口">第四章 类和接口</h1>
<h2 id="第13条_使类和成员的访问性最小">第13条 使类和成员的访问性最小</h2>
<p><strong> 原则：尽可能地使每个类或者成员不被外界访问。</strong><br>信息隐藏或封装可以有效的解除组成系统的各个模块之间的耦合关系，使得这些模块可以独立地开发、测试、优化、使用、理解和修改。这样可以加快系统开发速度，因为这些模块可以并行开发，它也减轻了维护的负担。</p>
<p>类和接口有两种访问级别：<br>包级私有（package-private）和公有（public）。</p>
<p>成员有四种返回级别，访问性逐渐递增：<br>私有的（private）&lt; 包级私有（package-private）也叫缺省（default）访问级别 &lt; 受保护的（protected）&lt; 公有的（public）。</p>
<p><em>除了公有静态final域的特殊之外，公有类都不应该包含公有域，并且要确保公有静态final域所引用的对象是不可变得。</em></p>
<h2 id="第14条_在公有类中使用访问方法而非公有域">第14条 在公有类中使用访问方法而非公有域</h2>
<p>原则上公有类永远都不应该暴露可变的域，应该提供方法来访问。让公有类暴露不可变的域其危害性比价小。<br>反面例子：</p>
<pre><code>java.awt.Point(<span class="keyword">public</span> <span class="keyword">int</span> x;<span class="keyword">public</span> <span class="keyword">int</span> y;)
java.awt.Dimension(<span class="keyword">public</span> <span class="keyword">int</span> width;<span class="keyword">public</span> <span class="keyword">int</span> height;)
</code></pre><p>如果类是包级私有的，或者私有的嵌套类，直接暴露它的数据域并没有本质的错误——假设这些数据域确实描述了该类所提供的抽象。<br>包级私有的类，域被限定在包含改类的包中。<br>私有的嵌套类，域改变的作用范围被进一步限制在外围类中。</p>
<h2 id="第15条_使类可变性最小化">第15条 使类可变性最小化</h2>
<p>不可变类指的是其实例不能被修改的类。<br>不可变类的优点：比可变类更加易于设计、实现和使用，不容易出错，且更加安全。<br>不可变对象本质是是同步的，它们不要求同步。<br><strong> 编写不可变类的规则： </strong></p>
<ol>
<li>不要提供任何会修改对象状态的方法。</li>
<li>保证类不会被扩展。</li>
<li>使所有的域都是final的。</li>
<li>使所有的域都成为私有的。</li>
<li>确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域，确保改域不会被外部修改。</li>
</ol>
<p><strong> 让类变成不可变类： </strong><br>一种方法是加上final修饰类。更加推荐的方法是，让类构造器变成私有，提供静态工厂来代替公有构造器。JDK中的例子，String、基本数据类型封装类。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span>(<span class="keyword">int</span> i);
<span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getInteger</span>(String nm);
</code></pre><h2 id="第16条_复合优先于继承">第16条 复合优先于继承</h2>
<p>继承功能很强大，但也存在诸多问题，因为它违反了封装性。只有当子类和超类之间确实存在子类型（is-a）关系时，使用继承才是恰当的。即便如此，如果子类和超类不在同一包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性，为了避免这种脆弱性，可以使用复合和转发机制来代替继承，尤其是存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能更加强大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//转发类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;E&gt; s;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">ForwardingSet</span>(Set&lt;E&gt; s) {</div><div class="line">        <span class="keyword">this</span>.s = s;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span>() {</div><div class="line">        s.clear();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span>(Object o) {</div><div class="line">        <span class="keyword">return</span> s.contains(o);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span>() {</div><div class="line">        <span class="keyword">return</span> s.isEmpty();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">        <span class="keyword">return</span> s.size();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span>() {</div><div class="line">        <span class="keyword">return</span> s.iterator();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) {</div><div class="line">        <span class="keyword">return</span> s.add(e);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span>(Object o) {</div><div class="line">        <span class="keyword">return</span> s.remove(o);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span>(Collection&lt;?&gt; c) {</div><div class="line">        <span class="keyword">return</span> s.containsAll(c);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span>(Collection&lt;? extends E&gt; c) {</div><div class="line">        <span class="keyword">return</span> s.addAll(c);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span>(Collection&lt;?&gt; c) {</div><div class="line">        <span class="keyword">return</span> s.removeAll(c);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span>(Collection&lt;?&gt; c) {</div><div class="line">        <span class="keyword">return</span> s.retainAll(c);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object[] <span class="title">toArray</span>() {</div><div class="line">        <span class="keyword">return</span> s.toArray();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; T[] <span class="title">toArray</span>(T[] a) {</div><div class="line">        <span class="keyword">return</span> s.toArray(a);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span>(Object o) {</div><div class="line">        <span class="keyword">return</span> s.equals(o);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>() {</div><div class="line">        <span class="keyword">return</span> s.hashCode();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        <span class="keyword">return</span> s.toString();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">InstrumentedSet</span>(Set&lt;E&gt; s) {</div><div class="line">        <span class="keyword">super</span>(s);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) {</div><div class="line">        addCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span>(Collection&lt;? extends E&gt; c) {</div><div class="line">        addCount += c.size();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAddCount</span>() {</div><div class="line">        <span class="keyword">return</span> addCount;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        InstrumentedSet&lt;String&gt; s = <span class="keyword">new</span> InstrumentedSet&lt;String&gt;(</div><div class="line">                <span class="keyword">new</span> HashSet&lt;String&gt;());</div><div class="line">        s.addAll(Arrays.asList(<span class="string">"Snap"</span>, <span class="string">"Crackle"</span>, <span class="string">"Pop"</span>));</div><div class="line">        System.out.println(s.getAddCount());</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>包装器不适合用在回调框架（callback framework）中，在回调框架中，对象把自身的引用传递给其他对象，用于后续的调用（回调）。因为被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用，回调时避开了外面的包装对象。这被称为SELF问题。</p>
<p>编写转发方法有点繁琐，但是只需要给每个接口编写一次构造器，转发类则可以通过包含接口的包替你实现。</p>
<h2 id="第17条_要么为继承而设计，并提供文档说明，要么就禁止继承">第17条 要么为继承而设计，并提供文档说明，要么就禁止继承</h2>
<p>对于为了继承而设计的类，该类文档必须精确的描述每个方法带来的影像。指明该方法或构造器调用了哪些可覆盖的方法，是以什么顺序调用的，每个调用结果又将怎样影像后续处理过程。</p>
<p>对于为了继承而设计的类，唯一的测试方法就是编写子类。必须在发布类之前先编写子类对类进行测试。</p>
<p>为了允许继承，类还必须遵守其他一些约束，构造器觉不能调用可被覆盖的方法，无论是直接调用还是间接调用，如果违反了这条规则，很可能导致程序失败。比如：</p>
<figure class="highlight Super"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Super {</div><div class="line">    <span class="comment">// Broken - constructor invokes an overridable method</span></div><div class="line">    <span class="keyword">public</span> <span class="title">Super</span>() {</div><div class="line">        overrideMe();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span>() {</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date date; <span class="comment">// Blank final, set by constructor</span></div><div class="line"></div><div class="line">    Sub() {</div><div class="line">        date = <span class="keyword">new</span> Date();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Overriding method invoked by superclass constructor</span></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span>() {</div><div class="line">        System.out.println(date);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Sub sub = <span class="keyword">new</span> Sub();</div><div class="line">        sub.overrideMe();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可能期待打印2次日期，但这里打印出来的结果是第一次为null，第二次才有值，第一次父类构造器调用子类overrideme的时候，子类的date还没有初始化。如果这里去调用不是打印方法，而是date的具体方法，就会出现空指针异常NullPointerException。</p>
<p>对于那些为了安全的进行子类化而设计和编写的文档的类，要禁止子类化。比如使用final类，私有构造器、静态工厂类代替，包装类。</p>
<h2 id="第18条_接口优于抽象类">第18条 接口优于抽象类</h2>
<p>Java只允许单继承，抽象类作为类型定义受到了极大的限制。</p>
<p><strong>接口优于抽象类：</strong></p>
<ul>
<li>现有的类可以很容易被更新，以实现新的接口。</li>
<li>接口是定义混合类型（mixin）的理想选择。 </li>
<li>接口允许我们构造非层次结构的类型框架。</li>
</ul>
<p>导出的每个重要的接口去实现骨架框架，更好的结合抽象类，接口定义类型，骨架实现类接管了所有与接口实现想关的工作。<br>    Interface——》AbstractInterface——》SimpleAdapter（Simple Implementation）——》DetailImplement</p>
<h2 id="第19条_接口只用于定义类型">第19条 接口只用于定义类型</h2>
<p>当类实现接口时，接口就充当可以引用这个类的实例的类型（type）。</p>
<p>接口应该只被用来定义类型，它们不应该被用来导出常量。</p>
<p>常量接口模式是对接口的不良使用。Java平台反面例子：java.io.ObjectStreamConstants。</p>
<h2 id="第20条_类层次优于标签类">第20条 类层次优于标签类</h2>
<p>有时候，可能会遇到带有2种甚至更多种风格的实例的类，并包含表示实例风格的标签域，例如，下面这个类可以表示圆形或矩形：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>{</div><div class="line">    <span class="keyword">enum</span> Shape {</div><div class="line">        RECTANGLE, CIRCLE</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Tag field - the shape of this figure</span></div><div class="line">    <span class="keyword">final</span> Shape shape;</div><div class="line"></div><div class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></div><div class="line">    <span class="keyword">double</span> length;</div><div class="line">    <span class="keyword">double</span> width;</div><div class="line"></div><div class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></div><div class="line">    <span class="keyword">double</span> radius;</div><div class="line"></div><div class="line">    <span class="comment">// Constructor for circle</span></div><div class="line">    Figure(<span class="keyword">double</span> radius) {</div><div class="line">        shape = Shape.CIRCLE;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Constructor for rectangle</span></div><div class="line">    Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) {</div><div class="line">        shape = Shape.RECTANGLE;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">double</span> area() {</div><div class="line">        <span class="keyword">switch</span> (shape) {</div><div class="line">        <span class="keyword">case</span> RECTANGLE:</div><div class="line">            <span class="keyword">return</span> length * width;</div><div class="line">        <span class="keyword">case</span> CIRCLE:</div><div class="line">            <span class="keyword">return</span> Math.PI * (radius * radius);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这种标签类有许多缺点，充斥着样板代码，包括枚举声明、标签域以及条件语句，过于冗长，容易出错，并且效力低下。</p>
<p>定义能表示多种风格对象的单个数据类型时，可以使用子类型化（subtyping），标签类是类层次的一种简单的仿效。将标签类转换成类层次，首先要为标签类中的每个方法定义一个包含抽象方法的抽象类， 这每个方法的行为都依赖于标签值。在Figure中只有这样一个方法：area，Figure具体的类层次如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>{</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">double</span> area();</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Figure</span> </span>{</div><div class="line">    <span class="keyword">final</span> <span class="keyword">double</span> radius;</div><div class="line"></div><div class="line">    Circle(<span class="keyword">double</span> radius) {</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">double</span> area() {</div><div class="line">        <span class="keyword">return</span> Math.PI * (radius * radius);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Figure</span> </span>{</div><div class="line">    <span class="keyword">final</span> <span class="keyword">double</span> length;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">double</span> width;</div><div class="line"></div><div class="line">    Rectangle(<span class="keyword">double</span> length, <span class="keyword">double</span> width) {</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">double</span> area() {</div><div class="line">        <span class="keyword">return</span> length * width;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="第21条_用函数对象表示策略">第21条 用函数对象表示策略</h2>
<p>函数指针的主要用途就是实现策略（Strategy）模式。实现策略模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名内部类来声明和实化这个具体策略类，当一个具体策略类是设计用来重复使用时，它的类通常就要被实现为私有的静态成员类，并通过共有的静态final域被导出，其类型为该策略的接口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匿名内部类实现策略</span></div><div class="line">Arrays.sort(stringArray, <span class="keyword">new</span> Comparator&lt;String&gt;() {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(String s1, String s2) {</div><div class="line">            <span class="keyword">return</span> s1.length() - s2.length();</div><div class="line">    }</div><div class="line">});</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重复使用时，使用这种方法，减少开销</span></div><div class="line">class Host {</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StrLenCmp</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">Serializable</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(String s1, String s2) {</div><div class="line">            <span class="keyword">return</span> s1.length() - s2.length();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">//reutrned comparator is serizlizable</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = <span class="keyword">new</span> StrLenCmp();</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="第22条_优先考虑静态成员类">第22条 优先考虑静态成员类</h2>
<p>嵌套类包含四种：静态成员类、非静态成员类、匿名类和局部类。</p>
<p>静态成员类的常见用法是作为共有的辅助器，仅当与它的外部类一起使用时才有意义。</p>
<p>非静态成员类的常见用法是定义一个Adapter，它允许外部类的实例被看作是另一个不相关的类的实例。</p>
<p>私有静态成员类的一种常见做法是用来表示外围类所代表的对象的组件。</p>
<p><strong>全套类的用法</strong></p>
<ul>
<li>如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合放在方法内部，就应该使用成员类。</li>
<li>如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则，就该做成静态的。</li>
<li>假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预设的类型可以说明这个类的特征，就要把它做成匿名类，否则就做成局部类。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="第四章_类和接口">第四章 类和接口</h1>
<h2 id="第13条_使类和成员的访问性最小">第13条 使类和成员的访问性最小</h2>
<p><strong> 原则：尽可能地使每个类或者成员不被外界访问。</strong><br>信息隐藏或封装可以有效的解]]>
    </summary>
    
      <category term="effective java" scheme="http://dreajay.github.io/tags/effective-java/"/>
    
      <category term="读书笔记" scheme="http://dreajay.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://dreajay.github.io/categories/java/"/>
    
      <category term="读书笔记" scheme="http://dreajay.github.io/categories/java/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[effective java-读书笔记-第三章 对于所有对象都通用的方法]]></title>
    <link href="http://dreajay.github.io/2014/11/30/effective%20java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://dreajay.github.io/2014/11/30/effective java-读书笔记-第三章 对于所有对象都通用的方法/</id>
    <published>2014-11-30T14:57:04.000Z</published>
    <updated>2014-11-30T15:02:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第三章_对于所有对象都通用的方法">第三章 对于所有对象都通用的方法</h1>
<p>所有非final方法（equals、hashCode、toString、clone、finalize）都有明确的通用约定，因为它们被设计成是要被覆盖的，如果不遵守，基于散列的集合（HashMap、HashSet、HashTable）可能无法结合该类一起运作。</p>
<h2 id="第8条_覆盖equals时请遵守通用约定">第8条 覆盖equals时请遵守通用约定</h2>
<p><strong>覆盖equals规范：</strong></p>
<ol>
<li>自反性（reflexive）。对于任何非null的引用值x，x.equals(x)必须返回true。</li>
<li>对称性（symmetric）。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li>
<li>传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)必须返回true。</li>
<li>一致性（consistent）。对于任何非null的引用值x和y，只有equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回true或者false。</li>
</ol>
<p><strong>实现equals方法：</strong></p>
<ol>
<li>使用==操作符检查“参数是否为这个对象的引用”。如果是，返回true。</li>
<li>使用instanceof操作符检查”参数是否为正确的类型”。如果不是返回false。</li>
<li>把参数转换成正确的类型。转换之前用instanceof判断，确保正确。</li>
<li>对于该类中的每个”关键“字段，检查参数中的字段是否与该对象中对应的字段相匹配。如果这些测试检查成功，返回true，否则返回false。</li>
<li>当编写完equals方法，编写单元测试校验它是否是对称的、传递的、一致的。</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>覆盖equals方法时总要覆盖hashCode方法。</li>
<li>不要企图让equals方法过于智能。比如File不应该和文件链接当作相等来看待。</li>
<li>不要将equals方法声明中的Object对象替换为其他类型。</li>
</ol>
<h2 id="第9条_覆盖equals时总要覆盖hashCode">第9条 覆盖equals时总要覆盖hashCode</h2>
<p>hashcode方法返回该对象的哈希码值。通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
<p><strong>hashCode常规协定</strong></p>
<ol>
<li>在应用程序执行期间，只要对象的equals方法的比较操作中所用的信息没有被修改，那么对这同一对象多次调用，hashCode方法都必须一致地返回同样的整数。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 </li>
<li>如果两个对象根据equals(Object)方法比较是相等的，那么调用两个对象中的任意一个对象上hashCode 方法都必须产生相同的整数结果。 </li>
<li>如果两个对象根据equals(Object)方法比较是不相等的，那么调用两个对象中的任意一个对象上hashCode 方法，则不一定产生不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 </li>
</ol>
<p><em>对于equals()相等的两个对象，其hashCode()返回的值一定相等</em></p>
<p><strong>重写hashCode方法</strong></p>
<ol>
<li>保证equals相等的对象hash码要一定相等</li>
<li>对于equals不同的对象要尽量做到hash码不同<br>具体步骤就是：<br>[1]把某个非零常数值（一般取素数），例如17，保存在int变量result中；<br>[2]对于对象中每一个关键域f（指equals方法中考虑的每一个域）：<br>[2.1]boolean型，计算(f ? 0 : 1);<br>[2.2]byte、char、short、int型，计算(int)f;<br>[2.3]long型，计算(int) (f ^ (f&gt;&gt;&gt;32));<br>[2.4]float型，计算Float.floatToIntBits(afloat);<br>[2.5]double型，计算Double.doubleToLongBits(adouble)得到一个long，再执行[2.3];<br>[2.6]对象引用，递归调用它的hashCode方法;<br>[2.7]数组域，对其中每个元素调用它的hashCode方法。<br>[3]将上面计算得到的散列码保存到int变量c，然后执行 result=37<em>result+c;<br>[4]返回result。<br>其实其思路就是：先取一个基数，然后对于equals()中考虑的每一个域，先转换成整数，再执行result=37</em>result+c;例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>(){</div><div class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</div><div class="line">    result = <span class="number">31</span>*result+age;</div><div class="line">    result=<span class="number">31</span>*result+name.hashCode();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="第10条_始终要覆盖toString">第10条 始终要覆盖toString</h2>
<p>toString通用约定指出被返回的字符串应该是简洁的、但信息丰富，并且易于阅读的表达形式。提供好的toString方法可以使类用起来更加舒适，当对象被传递给println、pringtf、字符串联合操作+、日志打印，toString会被自动调用。</p>
<p><em>建议所有的子类都覆盖toString方法。</em></p>
<h2 id="第11条_谨慎地覆盖clone">第11条 谨慎地覆盖clone</h2>
<p>Cloneable接口表明这样的对象允许克隆，它没有包含任何方法，它改变了超类中受保护的方法clone的行为，如果一个类实现了Cloneable接口，Object的clone方法就返回该对象的逐层拷贝，否则就会抛出CloneNotSupportException异常。</p>
<p>覆盖clone方法要非常小心，如果类里面含有复杂数据类型，要进行深度复制，如果类里面有final属性，则无法进行clone，因为final属性在clone时无法再进行赋值。</p>
<p><em>建议对象不使用clone方法，而使用静态拷贝工厂或拷贝构造器替代clone方法</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Obj</span>(Obj obj);</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Obj <span class="title">newInstance</span>(Obj obj);</div></pre></td></tr></table></figure>

<h2 id="第12条_考虑实现Comparable接口">第12条 考虑实现Comparable接口</h2>
<p>Comparable接口表明它的实例具有内在排序关系。</p>
<p><strong>Comparable声明：</strong></p>
<ol>
<li>如果第一个对象小于第二个对象，则第二个对象一定大于第一个对象；如果第一个对象等于第二个对象，则第二个对象一定等于第一个对象；如果第一个对象大于第二个对象，则第二个对象一定小于第一个对象。</li>
<li>如果第一个对象大于第二个对象，并且第二个对象又大于第三个对象，那么第一个对象一定大于第三个对象。</li>
<li>在比较时被认为相等的所有对象，它们跟别的对象做比较时一定会产生同样的结果。</li>
</ol>
<p>Comparable的声明和equals的声明类似，也遵守自反性、对称性和传递性。</p>
<p><em>强烈建议( (x.compareTo(y)==0)==(x.eauals(y) )，但这并非绝对必要。</em></p>
<p><strong>Comparable实现</strong></p>
<p>compareTo方法中的域的比较时顺序的比较，而不是等同性的比较。笔记对象引用域可以使通过递归地调用compareTo方法来实现。如果一个域没有实现Comparable接口，或者你需要一个非标准的排序关系，就可以使用一个显示的Comparator接口来代替。</p>
<figure class="highlight 例子"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span>(PhoneNumber pn) {</div><div class="line">        <span class="keyword">int</span> areaCodeDiff = areaCode - pn.areaCode;</div><div class="line">        <span class="keyword">if</span> (areaCodeDiff != <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> areaCodeDiff;</div><div class="line">        <span class="keyword">int</span> prefixDiff = prefix - pn.prefix;</div><div class="line">        <span class="keyword">if</span> (prefixDiff != <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> prefixDiff;</div><div class="line">        <span class="comment">// 下面可能会发生超出int最大值异常</span></div><div class="line">        <span class="keyword">return</span> lineNumber - pn.lineNumber;</div><div class="line">    }</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h1 id="第三章_对于所有对象都通用的方法">第三章 对于所有对象都通用的方法</h1>
<p>所有非final方法（equals、hashCode、toString、clone、finalize）都有明确的通用约定，因为它们被设计成是要被覆盖的，如果不遵守，基于散列的集合]]>
    </summary>
    
      <category term="effective java" scheme="http://dreajay.github.io/tags/effective-java/"/>
    
      <category term="读书笔记" scheme="http://dreajay.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://dreajay.github.io/categories/java/"/>
    
      <category term="读书笔记" scheme="http://dreajay.github.io/categories/java/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[进化：屌丝的互联网逆袭之路]]></title>
    <link href="http://dreajay.github.io/2014/11/25/%E8%BF%9B%E5%8C%96%EF%BC%9A%E5%B1%8C%E4%B8%9D%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E9%80%86%E8%A2%AD%E4%B9%8B%E8%B7%AF/"/>
    <id>http://dreajay.github.io/2014/11/25/进化：屌丝的互联网逆袭之路/</id>
    <published>2014-11-25T05:10:13.000Z</published>
    <updated>2014-11-25T05:33:33.000Z</updated>
    <content type="html"><![CDATA[<p>这是我在CSDN参加《<a href="http://blog.csdn.net/blogdevteam/article/details/40047403" target="_blank" rel="external">有奖试读&amp;征文——我们在互联网上奋斗的故事</a>》活动写的一篇读后感，并且获奖。</p>
<p>文章内容包括：</p>
<pre><code><span class="bullet">1. </span>书籍介绍
<span class="bullet">2. </span>屌丝的现状
<span class="bullet">3. </span>激情燃烧的岁月-互联网进化
<span class="bullet">4. </span>屌丝逆袭之路进化为互联网高富帅
<span class="bullet">5. </span>后记
<span class="bullet">6. </span>资料推荐
</code></pre><p>原文：<a href="http://blog.csdn.net/dreajay/article/details/40812623" target="_blank" rel="external">进化：屌丝的互联网逆袭之路</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是我在CSDN参加《<a href="http://blog.csdn.net/blogdevteam/article/details/40047403" target="_blank" rel="external">有奖试读&amp;征文——我们在互联网上奋斗的故事</]]>
    </summary>
    
      <category term="职业规划" scheme="http://dreajay.github.io/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
      <category term="互联网" scheme="http://dreajay.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
      <category term="迷茫" scheme="http://dreajay.github.io/tags/%E8%BF%B7%E8%8C%AB/"/>
    
      <category term="职业规划" scheme="http://dreajay.github.io/categories/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo+github搭建博客系统]]></title>
    <link href="http://dreajay.github.io/2014/11/24/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://dreajay.github.io/2014/11/24/hexo+github搭建博客系统/</id>
    <published>2014-11-24T13:02:40.000Z</published>
    <updated>2014-11-25T11:22:10.000Z</updated>
    <content type="html"><![CDATA[<p>个人博客大概包含了以下几个模块：首页、文章存档、文章分类、关于、友情链接，有些博客资源丰富，功能强大，还会加上一些诸如站内搜索、评论、分享、微博秀、广告等一些功能，很多框架都可以快速搭建起一个包含以上功能的博客，关于有哪些框架可以搭建博客，可以移步知乎讨论：<a href="http://www.zhihu.com/question/21981094" target="_blank" rel="external">应用github pages创建自己的个人博客</a>。<br><a id="more"></a><br>本博客是用hexo+github搭建的，选择<a href="http://hexo.io/" target="_blank" rel="external">hexo</a>是因为它比较简单，选择<a href="https://github.com" target="_blank" rel="external">github</a>因为它免费，哈哈，免费的东西总是能让人趋之若鹜。本博客的搭建也是参考很多他人资料，会在后面列出，我这里总结一下自己搭建博客各个模块用到的资源。</p>
<h1 id="创建github博客">创建github博客</h1>
<p>IT人员应该人手必备一个<a href="https://github.com" target="_blank" rel="external">github</a>账号，否则无法跟上这个逼格的年代，先注册一个github账号，然后创建自己的博客GitHub Pages，仓库名字固定结尾github.io，加上你的前缀，比如xxx.github.io。这里不会具体展开，相信你能做到：<a href="http://jingyan.baidu.com/article/ed2a5d1f3732cb09f7be1745.html" target="_blank" rel="external">http://jingyan.baidu.com/article/ed2a5d1f3732cb09f7be1745.html</a>。</p>
<h1 id="hexo">hexo</h1>
<h2 id="安装">安装</h2>
<p>因为<a href="http://hexo.io/" target="_blank" rel="external">hexo</a>是居于note.js的，所以要安装hexo，必须先安装note.js环境，这里并不一定需要很深入的了解notejs，如果你只想简单的使用hexo的话，安装很简单，直接到官网下载安装：<a href="http://www.nodejs.org" target="_blank" rel="external">http://www.nodejs.org</a>，安装完了notejs，打开命令行[cmd、git bash]执行命令即可安装hexo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo</div></pre></td></tr></table></figure>

<h2 id="快速开始">快速开始</h2>
<p><a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>的官网有很多文档资料，花一点时间看看文档，对你很有帮助，虽然是英文，但是不难，下面介绍几个常用的命令来搭建hexo博客。</p>
<h3 id="创建博客">创建博客</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo init c:/blog</div><div class="line">$ npm install</div></pre></td></tr></table></figure>

<h3 id="新建一篇文章">新建一篇文章</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"test"</span></div></pre></td></tr></table></figure>

<p>在sourece/_posts目录下会生成一个test.md文件，md为markdown文件格式，你可以用记事本来编辑，不过我更加推荐sublime text这款编辑器。markdown非常简单，更多请参考：<a href="https://github.com/riku/Markdown-Syntax-CN" target="_blank" rel="external">Markdown 语法 (简体中文版)</a>，在线编辑工具：<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">作业部落Cmd</a>, <a href="http://maxiang.info/" target="_blank" rel="external">马克飞象</a>。</p>
<h3 id="运行服务">运行服务</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure>

<p>访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>，即可看到刚才的文章。</p>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态文件">生成静态文件</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure>

<h3 id="发布到github">发布到github</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div></pre></td></tr></table></figure>

<p>需要在_config.yml配置你的github博客地址。</p>
<h2 id="hexo主题">hexo主题</h2>
<p>hexo有很多漂亮的主题：<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/hexojs/hexo/wiki/Themes</a>，你可以拿来修改成自己的，再次提醒参考<a href="http://hexo.io/docs/" target="_blank" rel="external">hexo</a>官方文档对你很有帮助。</p>
<h1 id="功能扩展">功能扩展</h1>
<p>给博客添加一些额外的功能，比如添加RSS订阅、分享、评论、404页面等待，这里不会具体展开怎么去做，具体还是需要自己去实践，可参看前人博客。</p>
<h2 id="网站图标">网站图标</h2>
<p><a href="http://www.bitbug.net/" target="_blank" rel="external">http://www.bitbug.net/</a><br><a href="http://creatr.cc/creatr/" target="_blank" rel="external">http://creatr.cc/creatr/</a></p>
<h2 id="分享">分享</h2>
<p>加网：<a href="http://www.jiathis.com/" target="_blank" rel="external">http://www.jiathis.com/</a><br>百度：<a href="http://share.baidu.com/code" target="_blank" rel="external">http://share.baidu.com/code</a><br>bShare：<a href="http://www.bshare.cn/" target="_blank" rel="external">http://www.bshare.cn/</a></p>
<h2 id="评论">评论</h2>
<p>多说：<a href="http://duoshuocom/" target="_blank" rel="external">http://duoshuo.com/</a> 国内用得多，方便快速<br>disqus：<a href="https://www.disqus.com/" target="_blank" rel="external">https://www.disqus.com/</a> 功能强大</p>
<h2 id="新浪微博秀">新浪微博秀</h2>
<p>微博秀：<a href="http://open.weibo.com/widget/like.php" target="_blank" rel="external">http://open.weibo.com/widget/like.php</a></p>
<h2 id="fork_me_on_github">fork me on github</h2>
<p>给博客加入github的fork链接：<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="external">https://github.com/blog/273-github-ribbons</a></p>
<h2 id="回到顶部">回到顶部</h2>
<p>参考文章：<a href="http://wuchong.me/blog/2014/01/08/hexo-scrollup/" target="_blank" rel="external">http://wuchong.me/blog/2014/01/08/hexo-scrollup/</a></p>
<h2 id="百度统计">百度统计</h2>
<p><a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">http://tongji.baidu.com/web/welcome/login</a></p>
<h2 id="站内搜索">站内搜索</h2>
<p>百度站长平台包含站内搜索并且还有其他很多功能：<a href="http://zhanzhang.baidu.com/" target="_blank" rel="external">http://zhanzhang.baidu.com/</a></p>
<h2 id="RSS订阅和sitemap">RSS订阅和sitemap</h2>
<p>RSS和sitemap有现成的插件可以很快集成到hexo，安装插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed</div><div class="line">$ npm install hexo-generator-sitemap</div></pre></td></tr></table></figure>

<p>修改_config.yml，增加以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Plugins:</div><div class="line">- hexo-generator-feed</div><div class="line">- hexo-generator-sitemap</div><div class="line"></div><div class="line"><span class="comment">#Feed Atom</span></div><div class="line">feed:</div><div class="line">  <span class="built_in">type</span>: atom</div><div class="line">  path: atom.xml</div><div class="line">  limit: <span class="number">20</span></div><div class="line"></div><div class="line"><span class="comment">#sitemap</span></div><div class="line">sitemap:</div><div class="line">  path: sitemap.xml</div></pre></td></tr></table></figure>

<p>执行命令 hexo d 能生成下面2个文件即表示成功：<br>xxx/public/atom.xml<br>xxx/public/sitemap.xml</p>
<h2 id="404页面">404页面</h2>
<p>当找不到你的网页时，提供一个友好的404会显得你更加专业。<br>腾讯404公益页面：<a href="http://www.qq.com/404/" target="_blank" rel="external">http://www.qq.com/404/</a></p>
<h2 id="图床">图床</h2>
<p>图床是用来存储你的图片的，你上传一张本地图片，图床会给你生成一个链接，你引用链接即可找到你的图片，有很多免费的图床可用：新浪、七牛。</p>
<h1 id="参考资料">参考资料</h1>
<hr>
<p>[1] <a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a> by cnfeat<br>[2] <a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">hexo 系列教程</a> by zippera<br>[3] <a href="http://zipperary.com/2013/05/26/ssh-errors-with-github/" target="_blank" rel="external">Git push时重复输入用户名密码的问题</a> by zippera</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>个人博客大概包含了以下几个模块：首页、文章存档、文章分类、关于、友情链接，有些博客资源丰富，功能强大，还会加上一些诸如站内搜索、评论、分享、微博秀、广告等一些功能，很多框架都可以快速搭建起一个包含以上功能的博客，关于有哪些框架可以搭建博客，可以移步知乎讨论：<a href="http://www.zhihu.com/question/21981094" target="_blank" rel="external">应用github pages创建自己的个人博客</a>。<br>]]>
    
    </summary>
    
      <category term="博客" scheme="http://dreajay.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://dreajay.github.io/tags/hexo/"/>
    
      <category term="github" scheme="http://dreajay.github.io/tags/github/"/>
    
      <category term="markdown" scheme="http://dreajay.github.io/tags/markdown/"/>
    
      <category term="博客" scheme="http://dreajay.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://dreajay.github.io/categories/%E5%8D%9A%E5%AE%A2/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mybatis实战之构建SqlSessionFactory]]></title>
    <link href="http://dreajay.github.io/2014/11/21/mybatis%E5%AE%9E%E6%88%98%E4%B9%8BSqlSessionFactory/"/>
    <id>http://dreajay.github.io/2014/11/21/mybatis实战之SqlSessionFactory/</id>
    <published>2014-11-21T03:40:57.000Z</published>
    <updated>2014-11-21T07:46:05.000Z</updated>
    <content type="html"><![CDATA[<p>SqlSessionFactory是mybatis的重要角色，是mybatis的整个程序的入口.<br><a id="more"></a></p>
<ol>
<li><p>SqlSessionFactory生命周期<br>SqlSessionFactory生命周期为贯穿整个应用程序,一般保持生命周期都使用同一个实例，所以SqlSessionFactory应该保持全局静态变量或使用单利模式来使用它。如果有多个数据源的时候，需要创建不同的SqlSessionFactory。</p>
</li>
<li><p>构建SqlSessionFactory<br>在mybatis中构建SqlSessionFactory有两种方式，一种是根据xml配置文件方式，另一种是也手动编写Java代码方式，手动构建比较繁琐，也不好维护，推荐使用xml配置方式，下面是详细代码。</p>
</li>
</ol>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * SqlSessionFactory生命周期为贯穿整个应用程序,一般保持生命周期都使用同一个实例，所以SqlSessionFactory应该保持全局静态变量或使用单利模式来使用它</div><div class="line"> * </div><div class="line"> *<span class="javadoctag"> @author</span> dreajay</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryManager</span> </span>{</div><div class="line">    <span class="comment">// SqlSessionFactory一个实例对应一个数据库配置</span></div><div class="line">    <span class="keyword">public</span> SqlSessionFactory sqlSessionFactory;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactoryManager INSTANCE = <span class="keyword">new</span> SqlSessionFactoryManager();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="title">SqlSessionFactoryManager</span>() {</div><div class="line">        sqlSessionFactory = buildSqlSessionFactoryFromXML(<span class="string">"SqlMapConfig.xml"</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span>() {</div><div class="line">        <span class="keyword">return</span> INSTANCE.sqlSessionFactory;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * 根据配置文件创建SqlSessionFactory</div><div class="line">     * </div><div class="line">     *<span class="javadoctag"> @param</span> SqlMapConfigFile</div><div class="line">     *            SqlMapConfig配置文件，文件应该放在当前的classpath中</div><div class="line">     *<span class="javadoctag"> @return</span> SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> SqlSessionFactory <span class="title">buildSqlSessionFactoryFromXML</span>(String SqlMapConfigFile) {</div><div class="line">        Reader reader = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            reader = Resources.getResourceAsReader(SqlMapConfigFile);</div><div class="line">            <span class="comment">// SqlSessionFactoryBuilder创建完SqlSessionFactory就不需要了，生命周期在方法内，不需要保存本地变量</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</div><div class="line">        } <span class="keyword">catch</span> (IOException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">            Log4jUtil.error(SqlSessionFactoryManager.class, <span class="string">"创建SqlSessionFactory出错"</span>, e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    reader.close();</div><div class="line">                    reader = <span class="keyword">null</span>;</div><div class="line">                } <span class="keyword">catch</span> (IOException e) {</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * 手动创建SqlSessionFactory</div><div class="line">     * </div><div class="line">     *<span class="javadoctag"> @return</span> SqlSessionFactory</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> SqlSessionFactory <span class="title">buildSqlSessionFactoryFromJava</span>() {</div><div class="line">        DataSource dataSource = <span class="keyword">null</span>;<span class="comment">// 数据库连接</span></div><div class="line">        <span class="comment">// dataSource = BlogDataSourceFactory.getBlogDataSource();</span></div><div class="line">        TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</div><div class="line">        Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</div><div class="line">        Configuration configuration = <span class="keyword">new</span> Configuration(environment);</div><div class="line">        configuration.addMapper(UserMapper.class);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>SqlSessionFactory是mybatis的重要角色，是mybatis的整个程序的入口.<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://dreajay.github.io/tags/java/"/>
    
      <category term="mybatis" scheme="http://dreajay.github.io/tags/mybatis/"/>
    
      <category term="SqlSessionFactory" scheme="http://dreajay.github.io/tags/SqlSessionFactory/"/>
    
      <category term="java" scheme="http://dreajay.github.io/categories/java/"/>
    
      <category term="mybatis" scheme="http://dreajay.github.io/categories/java/mybatis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <link href="http://dreajay.github.io/2014/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://dreajay.github.io/2014/11/19/设计模式之单例模式/</id>
    <published>2014-11-18T17:49:49.000Z</published>
    <updated>2014-11-28T13:04:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<p>Singleton是指在应用程序中只被实例化一次的类。</p>
<a id="more"></a>

<h2 id="创建单例模式的方法">创建单例模式的方法</h2>
<h3 id="第一种">第一种</h3>
<p>恶汉式，程序加载自己时就会创建静态Singleton实例。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过静态final变量获取Singleton</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过静态方法获取实例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第二种">第二种</h3>
<p>懒汉式，当需要使用的时候再进行创建，使用synchronized锁保证只能生成一个实例，否则多线程下可能会产生多个实例，但synchronized会导致性能下降。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">            sinleton = <span class="keyword">new</span> Singleton();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sinleton;</div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第三种">第三种</h3>
<p>懒汉式，下面这种方法是上面方法的改进，但多线程下可能造成创建多个实例问题，假如第一次在创建对象的时候，另外一个线程已经进入if(singleton == null) 中等待synchronized，最后执行完就会产生两个Singleton，导致单例失效。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class) {</div><div class="line">                sinleton = <span class="keyword">new</span> Singleton();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sinleton;</div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第四种">第四种</h3>
<p>这个方法避免了第三种创建多个实例对象的问题，并且避免了多个线程排队等候的现象。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//私有构造器</span></div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {   </div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span>() {</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class){</div><div class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) {</div><div class="line">                    sinleton = <span class="keyword">new</span> Singleton();</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> sinleton;</div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第五种">第五种</h3>
<p>改良的懒汉模式，通过私有静态final内部类间接构造Singleton。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>() {}  </div><div class="line">    <span class="comment">//私有静态</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>{  </div><div class="line">        <span class="comment">//static final Singleton</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {  </div><div class="line">        <span class="keyword">return</span> Holder.instance;  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="第六种">第六种</h3>
<p>枚举实现单例模式，在《effective java》一书中有介绍，这是实现单例的最佳方式。之前第一种方法第一个例子通过静态final变量获取Singleton，通过反射调用私有构造器可以创建另一个实例，会导致破坏Singleton，防御方法为是在构造器中进行判断第二次创建时抛出异常；另外一方面为了给Singleton序列化(Serializable)，仅仅在声明中加上“implements Serializable ”，是不够的，为了保证Singleton，必须声明所有实例域都是瞬时的（transient），并提供一个readResolve方法，否则每次反序列化时都会创建一个新的实例，使用枚举方法简洁并无偿的提供了序列化机制，绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候。</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton {</div><div class="line">    INSTANCE {</div><div class="line">        <span class="comment">// init . . .</span></div><div class="line">    };</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span>() {</div><div class="line">        <span class="comment">// do . . .</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>枚举创建单例这么多好处，以后应该多用枚举方式来实现单例模式；当Singleton不需要序列化，或一般不会被反射时，我一般使用第一种恶汉式来创建，简单，也不需要考虑多线程，虽然一开始就需要消耗内存去创建，但现在的机器是不用太担心的，恶汉式会让单例变得更加复杂。<br><strong><em>注意：</em></strong><br>在分布式式中，程序可能会跨服务器、跨JVM，包含多个类装载器，Singleton可能会被不同的类装载器装载，这样就会导致Singleton失效。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="定义">定义</h2>
<p>Singleton是指在应用程序中只被实例化一次的类。</p>
]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://dreajay.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://dreajay.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Singleton模式" scheme="http://dreajay.github.io/tags/Singleton%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://dreajay.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
